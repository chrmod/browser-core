'use strict';
const { classes: Cc, interfaces: Ci, utils: Cu } = Components;

var EXPORTED_SYMBOLS = ['CliqzClusterHistory'];

Cu.import('resource://gre/modules/XPCOMUtils.jsm');
XPCOMUtils.defineLazyModuleGetter(this, 'CliqzUtils',
  'chrome://cliqzmodules/content/CliqzUtils.jsm');

// Only available in FF 22
// https://developer.mozilla.org/en-US/docs/Web/API/URL
// - TODO: replace with something that works in old browsers
Cu.importGlobalProperties(['URL']);


var CliqzClusterHistory = CliqzClusterHistory || {
    LOG_KEY: 'CliqzClusterHistory',
    log: function(str) {
        CliqzUtils.log(str, CliqzClusterHistory.LOG_KEY);
    },
    
    all_rules: undefined,

    /**
     * Loads external data necessary for history clustering.
     */
    init: function() {
        CliqzClusterHistory.log("init");
        CliqzUtils.httpGet('chrome://cliqz/content/cluster-rules-autogenerated.json',
                function success(req){
                    CliqzClusterHistory.all_rules = JSON.parse(req.response).brands;
                    CliqzClusterHistory.log("Loaded rules: " + JSON.stringify(CliqzClusterHistory.all_rules))                    
                },
                function error(){
                    CliqzClusterHistory.log("Could not load clustering rules file.")
                }
            );

    },

    /**
     * Tries to cluster the history.
     *
     * @return <tt>[is_clustered, filtered_history]</tt>: if the history could
     *         be clustered, @c is_clustered will be true and
     *         @c filtered_history will contain all the items in the history
     *         that do not lead to the clustered domain; otherwise, we return
     *         @c false and the full history.
     */
    cluster: function(history, cliqzResults, q) {
        // returns null (do nothing) if less that 5 results from history and one domains does not take >=70%
        if (history==null) return [false, null];

        var freqHash = {};
        var maxCounter = -1;
        var maxDomain = null;
        var historyTrans = [];

        for (let i = 0; history && i < history.matchCount; i++) {
            let style = history.getStyleAt(i),
                value = history.getValueAt(i),
                image = history.getImageAt(i),
                comment = history.getCommentAt(i),
                label = history.getLabelAt(i);

                historyTrans.push({style: style, value: value, image: image, comment: comment, label: label});
                var urlDetails = CliqzUtils.getDetailsFromUrl(value),
                    domain = urlDetails.host;

                if (freqHash[domain]==null) freqHash[domain]=[];
                freqHash[domain].push(i);

                if (freqHash[domain].length>maxCounter) {
                    maxDomain = domain;
                    maxCounter = freqHash[domain].length;
                }
        }

        CliqzClusterHistory.log('maxDomain: ' + maxDomain);

        if (history.matchCount < 10) {
            CliqzClusterHistory.log('History cannot be clustered, matchCount < 10');
            return [false, historyTrans];
        }

        var historyTransFiltered = [];
        var historyTransRemained = [];
        let j = 0;
        for (let i=0; i<freqHash[maxDomain].length; i++) {
            for (; j <= freqHash[maxDomain][i]; j++) {
                if (j < freqHash[maxDomain][i]) {
                    historyTransRemained.push(historyTrans[j]);
                } else {
                    historyTransFiltered.push( { url: historyTrans[j].value,
                                                 title: historyTrans[j].comment });
                }
            }
        }
        while (j < historyTrans.length) {
            historyTransRemained.push(historyTrans[j]);
            j++;
        }


        // find the first ruleset matching this domain
        var rules = undefined;
        for (let r in CliqzClusterHistory.all_rules) {
            for (let d = 0; d < CliqzClusterHistory.all_rules[r].match_domains.length; d++) {
                CliqzClusterHistory.log(CliqzClusterHistory.all_rules[r].match_domains[d]);
                if (CliqzClusterHistory.all_rules[r].match_domains[d] == maxDomain) {
                    rules = CliqzClusterHistory.all_rules[r];
                    break;
                }
            }
            if (rules)
                break;
        }

        // No rules, abort and continue history as normal
        if (!rules) {
            CliqzClusterHistory.log('No ruleset for domain: ' + maxDomain);
            return [false, historyTrans];
        }

        var threshold = CliqzUtils.getPref("domainClusterThreshold", 0.5)

        if (maxCounter < (history.matchCount * threshold)) {
            CliqzClusterHistory.log('History cannot be clustered, maxCounter < belowThreshold: ' + maxCounter + ' < ' + history.matchCount * threshold);
            return [false, historyTrans];
        }

        CliqzClusterHistory.log(JSON.stringify([maxDomain, maxCounter, history.matchCount, freqHash]));


        var clusteredHistory = CliqzClusterHistory.collapse(maxDomain, rules, historyTransFiltered);
        CliqzClusterHistory.log(JSON.stringify(clusteredHistory));

        if (!clusteredHistory) {
            // the collapse failed, perhaps: too few data?, missing template, error?
            // if clusteredHistory return the normal history
            CliqzClusterHistory.log('History cannot be clustered, clusteredHistory is null');
            return [false, historyTrans];

        } else if (clusteredHistory['topics'].length == 0) {
            // no URLs related to the topics defined for the site found in
            // the history URLs
            CliqzClusterHistory.log('History cannot be clustered, no URLs related to the topics');
            return [false, historyTrans];

        } else {
            historyTransFiltered[0]['data'] = clusteredHistory;
            historyTransFiltered[0]['style'] = 'cliqz-cluster';
            var v = [true, [historyTransFiltered[0]].concat(historyTransRemained)];

            CliqzClusterHistory.log(JSON.stringify([historyTransFiltered[0]]));
            return v;
        }
    },
    match_url: function(cond, history) {
        CliqzClusterHistory.log("applying match rule: " + JSON.stringify(cond));

        var matching = [];

        for(let i = 0; i < history.length; i++) {
            var url = history[i].url;
            CliqzClusterHistory.log(" ... to " + url);
            var url_parts = new URL(url)

            var matched_scheme = false,
                matched_domain = false,
                matched_path = false,
                matched_query = false,
                matched_fragment = false;

            // SCHEME
            if(!cond.scheme || url_parts.protocol.search(cond.scheme) != -1)
                matched_scheme = true;

            // DOMAIN
            if(!cond.domain || url_parts.hostname.search(cond.domain) != -1)
                matched_domain = true;

            // PATH
            if(!cond.path || url_parts.pathname.search(cond.path) != -1)
                matched_path = true;

            // QUERY
            if(!cond.query || url_parts.search.replace(/^\?/, '').search(cond.query) != -1)
                matched_query = true;

            // FRAGMENT
            if(!cond.fragment || url_parts.hash.replace(/^#/, '').search(cond.fragment) != -1)
                matched_fragment = true;

            CliqzClusterHistory.log("matched: " + matched_scheme + matched_domain + matched_path + matched_query + matched_fragment);

            if(matched_scheme && matched_domain && matched_path && matched_query && matched_fragment)
                matching.push(history[i]);
        }
        return matching;
    },
    extract_with_regex: function(entry, rule) {
        CliqzClusterHistory.log("entry: " + JSON.stringify(entry) + " rule: " + JSON.stringify(rule));
        if(!rule)
            return undefined;

        var url_parts = new URL(entry.url);

        if (typeof rule == 'string') {
            return rule;
        } else {
            if(!rule.var || !rule.pattern) {
                CliqzClusterHistory.log("Error, var and pattern required for regex rule. Ignoring: ");
                CliqzClusterHistory.log(JSON.stringify(rule));
            } else {
                var source;
                if(rule.var == 'title')
                    source = entry.title;
                else if(rule.var == 'domain')
                    source = url_parts.host;
                else if(rule.var == 'path')
                    source = url_parts.pathname;
                else if(rule.var == 'query')
                    source = url_parts.search.replace(/^\?/, '');
                else if(rule.var == 'fragment')
                    source = url_parts.hash.replace(/^#/, '');

                if(source) {

                    CliqzClusterHistory.log("source: " + source);
                    CliqzClusterHistory.log("pattern: " + rule.pattern);
                    var regex = new RegExp(rule.pattern);
                    var temp = regex.exec(source);
                    if(temp) {
                        CliqzClusterHistory.log("matched: " + temp[1]);
                        return temp[1];
                    } else {
                        return undefined;
                    }
                }
            }
        }

    },
    rewrite_url: function(entry, rule) {
        if(!rule)
            return undefined;

        // just use the static URL
        if(typeof rule == 'string') {
            return rule;
        } 

        var url = entry.url;
        var url_parts = new URL(url);

        function rewrite(text, pattern) {
            if(pattern == undefined)
                return text;

            var regex = new RegExp(pattern);
            var temp = regex.exec(text);
            if(temp && temp.length > 1) {
                return temp[1]; // matched a group
            } else if(temp) {
                return temp[0]; // no group, return matching text
            } else {
                return pattern;
            }
        }

        // extract individual parts based on pattern in rule
        var scheme = rewrite(url_parts.protocol, rule.scheme);
        var domain = rewrite(url_parts.host, rule.domain);
        var path = rewrite(url_parts.pathname, rule.path);
        var query = rewrite(url_parts.search, rule.query ? rule.query.replace(/^\?/, '') : undefined);
        var fragment = rewrite(url_parts.hash, rule.fragment ? rule.fragment.replace(/^#/, '') : undefined);

        // combine them back into a full URL
        var url = scheme + "//" + domain + path;
        if(query)
            url += '?' + query;
        if(fragment)
            url += '#' + fragment;

        return url;
    },
    collapse: function(domain, definition, history) {
        CliqzClusterHistory.log('Collapsing domain: ' + domain + ' ' + history.length + ' items');
        CliqzClusterHistory.log(JSON.stringify(definition));

        var rules = definition.rules;

        // Step 1 - filter all history that does not match the list of domains
        // for the brand

        // already filtered in the calling function
        // TODO: check if this is reasonable, what if a brand spans multiple domains?


        // Step 2 - apply each rule in order to categorize all history items
        var category_order = [];
        var categories = {};
        for (let r = 0; r < rules.length; r++) {

            var match = rules[r].match;
            if(match) {
                var matching = CliqzClusterHistory.match_url(match, history);
                CliqzClusterHistory.log("matched urls: " + JSON.stringify(matching));

                // check special case of 'always_show' rules
                if (matching.length == 0 && rules[r].always_show) {
                    var temp = {
                        url: rules[r].url,
                        title: rules[r].title
                    };
                    matching = [temp];
                }

                // finalize each matching entry by placing in a category and
                // and setting title and URL.
                for(let m = 0; m < matching.length; m++) {
                    var entry = {}

                    // get category: static or from regex
                    var category = CliqzClusterHistory.extract_with_regex(matching[m], rules[r].category);

                    if(category) {
                        // is this the first time we've seen this category?
                        if(category_order.indexOf(category) == -1) {
                            category_order.push(category);
                            categories[category] = [];
                        }

                        // assign the raw entry to the category
                        matching[m].category = category;

                        // apply title
                        var new_title = CliqzClusterHistory.extract_with_regex(matching[m], rules[r].title);
                        if(new_title)
                            entry.title = new_title;
                        else
                            entry.title = matching[m].title;

                        // rewrite the url
                        var new_url = CliqzClusterHistory.rewrite_url(matching[m], rules[r].url);
                        if(new_url)
                            entry.url = new_url;
                        else
                            entry.url = matching[m].url;

                        entry.old_urls = [matching[m].url];

                        categories[category].push(entry);
                    }
                }
            }
        }

        // Step 3 - place all uncategoried entries in special category
        if(category_order.indexOf('uncategorized') == -1) {
            category_order.push('uncategorized')
            categories['uncategorized'] = []
        }
        for(let i = 0; i < history.length; i++) {
            if(!history[i].category)
                categories['uncategorized'].push(history[i])
        }

        // Step 4 - check for valid config
        var base = categories.base
        if(!categories.base) {
            CliqzClusterHistory.log("Error, no base entry");
            return undefined;
        }

        // Step 5 - collapse urls with the same url together
        for(let i = 0; i < category_order.length; i++) {
            if(category_order[i] == "uncategorized")
                // don't try to collapse uncategorized entries
                continue;

            var entries = categories[category_order[i]];
            CliqzClusterHistory.log("entries: " + JSON.stringify(entries));

            // remove entries that have the same url as a previous entry
            var keep = [];
            for(let h = 0; h < entries.length; h++) {
                var entry = undefined;
                for(let k = 0; k < keep.length; k++) {
                    if(keep[k].url == entries[h].url) {
                        entry = keep[k];
                        break;
                    }
                }
                if(entry) // found duplicate, combine them
                    entry.old_urls = entry.old_urls.concat(entries[h].old_urls);
                else
                    keep.push(entries[h]);
            }

            categories[category_order[i]] = keep;
        }
        CliqzClusterHistory.log("Catgories: " + JSON.stringify(categories));


        // Step 6 - build cluster config
        var cluster = {
            name: categories.base[0].title,
            summary: definition.summary,
            url: categories.base[0].url,
            control: [],
            control_set: {},
            topics: [],
        };

        for(let c = 0; c < category_order.length; c++) {
            if(category_order[c] == 'control')
                cluster.control = categories.control;
            else if(category_order[c] == 'base')
                ;
            //else if(category_order[c] == 'exclude')
            //     ;
            //else if(cateogry_order[c] == 'uncategorized')
            //     ;
            else {
                var topic = {
                    'label': category_order[c],
                    'labelUrl': 'http://test.test.test/',
                    'color': "#CC3399",
                    'urls': categories[category_order[c]]
                };
                cluster.topics.push(topic);
            }
        }

        //print json.dumps(uncategorized, indent=2)
        return cluster;

    },
};

